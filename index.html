<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Reels - Find Your Next Watch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .tag { display: inline-flex; align-items: center; padding: 4px 10px; margin: 4px; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; }
        .tag-remove { margin-left: 8px; cursor: pointer; width: 16px; height: 16px; }
        .details-panel::-webkit-scrollbar, .ranking-panel::-webkit-scrollbar { display: none; }
        .details-panel, .ranking-panel { -ms-overflow-style: none; scrollbar-width: none; }
        .reel-container { scroll-snap-type: y mandatory; overflow-y: scroll; -ms-overflow-style: none; scrollbar-width: none; }
        .reel-container::-webkit-scrollbar { display: none; }
        .reel-item { scroll-snap-align: start; flex: 0 0 100%; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        .autocomplete-results { position: absolute; background-color: #1f2937; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; width: 100%; z-index: 10; margin-top: 4px; }
        .autocomplete-item { padding: 8px 12px; cursor: pointer; }
        .autocomplete-item:hover { background-color: #374151; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-left-color: #fff; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .super-like-toast {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: #8b5cf6; color: white; padding: 10px 20px;
            border-radius: 9999px; font-weight: 600; z-index: 100;
            opacity: 0; transition: opacity 0.5s, top 0.5s;
        }
        .active-btn { background-color: #4f46e5; }
    </style>
</head>
<body class="bg-gray-900 text-white h-full antialiased overflow-hidden flex">

    <div id="super-like-toast" class="super-like-toast">Super Like! âœ¨</div>
    <audio id="audio-unlocker" muted playsinline></audio>

    <div id="initial-loading-overlay" class="hidden absolute inset-0 bg-gray-900/90 backdrop-blur-sm flex flex-col items-center justify-center z-50 transition-opacity duration-300">
        <div class="spinner"></div>
        <p class="mt-4 text-lg font-semibold">Preparing your recommendations...</p>
    </div>

    <div class="flex-grow h-full relative">
        <div id="setup-screen" class="min-h-full flex flex-col items-center justify-center p-4 transition-opacity duration-500">
            <div class="w-full max-w-2xl mx-auto bg-gray-800/50 backdrop-blur-sm rounded-2xl p-6 md:p-8 shadow-2xl border border-gray-700 fade-in">
                <div class="text-center mb-8"><h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500">AnimeReels</h1><p class="text-gray-300 mt-2">Tell us your tastes to create your personalized reel.</p></div>
                <div class="mb-4"><label class="block text-sm font-medium text-gray-200 mb-2">Your Username (for this session)</label><input id="username-input" type="text" placeholder="Enter a temporary username..." class="w-full bg-gray-900 rounded-lg p-3 border border-gray-700 focus:ring-2 focus:ring-indigo-500 outline-none"></div>
                <div class="mb-4 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Must-Have Genres</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-indigo-500"><div id="genres-tags" class="flex flex-wrap"></div><input id="genres-input" type="text" placeholder="Type genre and press Enter..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="genres-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="mb-4 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Animes You Like</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-green-500"><div id="liked-tags" class="flex flex-wrap"></div><input id="liked-input" type="text" placeholder="e.g., Attack on Titan..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="liked-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="mb-6 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Animes You Dislike</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-red-500"><div id="disliked-tags" class="flex flex-wrap"></div><input id="disliked-input" type="text" placeholder="e.g., Sword Art Online..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="disliked-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="flex items-center justify-center my-4"><label for="explicit-toggle" class="flex items-center cursor-pointer text-sm text-gray-400"><input type="checkbox" id="explicit-toggle" class="form-checkbox h-4 w-4 text-indigo-600 bg-gray-800 border-gray-600 rounded focus:ring-indigo-500"><span class="ml-2">Show Explicit Genres</span></label></div>
                <button id="generate-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 disabled:bg-gray-500 disabled:hover:bg-gray-500 disabled:scale-100 flex items-center justify-center"><span id="generate-button-text">Generate My Reel</span><span id="generate-button-spinner" class="hidden"><svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></span></button>
            </div>
        </div>

        <div id="reels-screen" class="h-full w-full max-w-md mx-auto relative hidden flex-col">
            <div id="reel-container" class="reel-container h-full w-full"></div>
            <button id="exit-session-button" title="Exit and Delete Session Data" class="absolute top-4 left-4 bg-black/30 p-2.5 rounded-full hover:bg-black/50 transition-all z-20"><svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
            <button id="unmute-button" title="Unmute Video" class="absolute top-4 right-4 bg-black/30 p-2.5 rounded-full hover:bg-black/50 transition-all z-20"><i data-lucide="volume-x" class="w-5 h-5"></i></button>
            <div id="unmute-overlay" class="absolute inset-0 bg-black/50 flex items-center justify-center z-30 cursor-pointer"><div class="text-center"><i data-lucide="volume-x" class="w-16 h-16 mx-auto"></i><p class="mt-4 font-semibold">Tap to Unmute</p></div></div>
        </div>
    </div>
    
    <div id="ranking-panel-container" class="w-64 bg-gray-800/50 border-l border-gray-700 h-full flex-shrink-0 p-4 hidden ranking-panel overflow-y-auto">
        <h3 class="text-lg font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500 mb-4">Your Dashboard</h3>
        <div id="ranking-list"></div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        const API_BASE_URL = 'https://instagranime-1.onrender.com';
        // --- STATE VARIABLES ---
        let currentUserId = null, players = {}, isMuted = true, recommendationScores = {}, recommendationSignals = {}, seenAnimeIds = new Set(), sessionScrolledPastIds = new Set(), isRefreshing = false, currentlyVisibleReel = null, progressCheckIntervals = {}, animeDetailsCache = {};
        let isApiReady = false, hasUnlockedAudio = false, isFeedbackLocked = false;
        let apiReadyPromise = new Promise(resolve => { window.onYouTubeIframeAPIReady = () => { isApiReady = true; resolve(); }; });
        
        let setupScreen, reelsScreen, generateButton, reelContainer, exitButton, unmuteButton, unmuteOverlay, rankingPanelContainer, initialLoadingOverlay;
        let inputs = {};
        let intersectionObserver;
        let likeClickTracker = { animeId: null, count: 0, timer: null };
        let activeReelId = null;

        function showSuperLikeToast() {
            const toast = document.getElementById('super-like-toast');
            toast.style.opacity = '1';
            toast.style.top = '40px';
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.top = '20px';
            }, 2000);
        }

        function updateRankingPanel() {
            const rankingList = document.getElementById('ranking-list');
            const sortedAnime = Object.entries(recommendationScores).sort((a, b) => b[1] - a[1]);
            const signalToIcon = {
                'like_button': '<i data-lucide="heart" class="w-3 h-3 text-pink-400"></i>',
                'super_like_button': '<i data-lucide="sparkles" class="w-3 h-3 text-yellow-400"></i>',
                'save_to_watchlist': '<i data-lucide="bookmark" class="w-3 h-3 text-indigo-400"></i>',
                'watched_10_seconds': '<i data-lucide="play-circle" class="w-3 h-3 text-green-400"></i>',
                'scrolled_past': '<i data-lucide="skip-forward" class="w-3 h-3 text-gray-400"></i>'
            };
            rankingList.innerHTML = sortedAnime.map(([id, score], index) => {
                const title = animeDetailsCache[id] ? animeDetailsCache[id].title : 'Unknown';
                const signals = Array.from(recommendationSignals[id] || []);
                const signalIconsHTML = signals.map(sig => signalToIcon[sig] || '').join('');
                return `<div class="flex items-center justify-between mb-3 text-sm"><span class="font-bold text-indigo-400 mr-2">${index + 1}.</span><span class="flex-grow truncate text-gray-300">${title}</span><span class="flex items-center space-x-1 ml-2">${signalIconsHTML}</span><span class="font-medium text-gray-400 ml-2">${score.toFixed(2)}</span></div>`;
            }).join('');
            lucide.createIcons();
        }

        function reorderUpcomingReel() {
            if (!currentlyVisibleReel) return;
            const sortedAnime = Object.entries(recommendationScores).sort((a, b) => b[1] - a[1]);
            for (const [animeIdStr] of sortedAnime) {
                const animeId = parseInt(animeIdStr, 10);
                if (sessionScrolledPastIds.has(animeId)) {
                    continue;
                }
                const targetReel = reelContainer.querySelector(`[data-anime-id='${animeId}']`);
                if (targetReel && targetReel !== currentlyVisibleReel) {
                    currentlyVisibleReel.after(targetReel);
                    setupIntersectionObserver();
                    break;
                }
            }
        }
        
        async function sendFeedbackSignal(animeId, reason, isAutomatic = false) {
            if (!currentUserId || (isFeedbackLocked && !isAutomatic)) return null;
            if (!isAutomatic) isFeedbackLocked = true;
            try {
                if (!recommendationSignals[animeId]) recommendationSignals[animeId] = new Set();
                const signalReason = (reason === 'super_like_button') ? 'like_button' : reason;
                if (recommendationSignals[animeId].has(signalReason) && !isAutomatic && reason !== 'save_to_watchlist') {
                    recommendationSignals[animeId].delete(signalReason);
                } else {
                    recommendationSignals[animeId].add(signalReason);
                }
                if (reason === 'super_like_button') recommendationSignals[animeId].add('super_like_button');
                updateRankingPanel();
                const feedbackResponse = await fetch(`${API_BASE_URL}/api/feedback`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: currentUserId, animeId: parseInt(animeId), reason })
                });
                if (!feedbackResponse.ok) return null;
                return await feedbackResponse.json();
            } catch (error) {
                console.error("Failed to process feedback:", error);
                return null;
            } finally {
                if (!isAutomatic) isFeedbackLocked = false;
            }
        }

        async function rescoreRemainingReels() {
             const animeIdsToRescore = Object.keys(animeDetailsCache);
             if (animeIdsToRescore.length > 0) {
                const rescoreResponse = await fetch(`${API_BASE_URL}/api/rescore`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: currentUserId, anime_ids: animeIdsToRescore })
                });
                if (rescoreResponse.ok) {
                    const newScores = await rescoreResponse.json();
                    Object.entries(newScores).forEach(([id, score]) => {
                        if (recommendationScores[id] !== undefined) recommendationScores[id] = score;
                    });
                    updateRankingPanel();
                    reorderUpcomingReel();
                }
            }
        }

        async function refreshRecommendations() {
            if (isRefreshing) return;
            isRefreshing = true;
            const payload = {
                user_id: currentUserId,
                seen_anime_ids: Array.from(seenAnimeIds),
                allow_explicit: document.getElementById('explicit-toggle').checked,
                genres: inputs.genres.getTags()
            };
            try {
                const response = await fetch(`${API_BASE_URL}/api/generate_reel`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                const data = await response.json();
                if (data.recommendations && data.recommendations.length > 0) {
                    appendReels(data.recommendations);
                }
            } catch (error) {
                console.error("Failed to refresh recommendations:", error);
            } finally {
                isRefreshing = false;
            }
        }
        
        async function onGenerateReel() {
            const username = inputs.username.value.trim();
            if (!username) { alert("Please enter a username."); return; }
            const payload = {
                username,
                liked_anime: inputs.liked.getTags(),
                disliked_anime: inputs.disliked.getTags(),
                seen_anime_ids: [],
                allow_explicit: document.getElementById('explicit-toggle').checked,
                genres: inputs.genres.getTags()
            };
            toggleLoading(true);
            try {
                const response = await fetch(`${API_BASE_URL}/api/generate_reel`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                currentUserId = data.user_id;
                initialLoadingOverlay.classList.remove('hidden');
                setupScreen.classList.add('hidden');
                loadReels(data.recommendations);
                await preloadInitialReels(data.recommendations);
                initialLoadingOverlay.classList.add('hidden');
                reelsScreen.classList.remove('hidden');
                reelsScreen.classList.add('flex');
                rankingPanelContainer.classList.remove('hidden');
            } catch (error) {
                console.error('Failed to fetch recommendations:', error);
                alert(`Error: ${error.message}`);
            } finally {
                toggleLoading(false);
            }
        }

        async function onExitSession() {
            if (currentUserId) {
                try { await fetch(`${API_BASE_URL}/api/user/${currentUserId}`, { method: 'DELETE' }); } catch (error) { console.error("Error deleting user:", error); }
            }
            window.location.reload();
        }

        function onToggleMute() {
            if (!hasUnlockedAudio) {
                document.getElementById('audio-unlocker').play().catch(e => {});
                document.getElementById('audio-unlocker').pause();
                hasUnlockedAudio = true;
            }
            isMuted = !isMuted;
            unmuteOverlay.classList.add('hidden');
            const icon = unmuteButton.querySelector('i');
            icon.setAttribute('data-lucide', isMuted ? 'volume-x' : 'volume-2');
            lucide.createIcons({nodes: [icon]});
            Object.values(players).forEach(p => {
                if (p && typeof p.mute === 'function') { if (isMuted) p.mute(); else p.unMute(); }
            });
        }

        function toggleLoading(isLoading) {
            generateButton.disabled = isLoading;
            document.getElementById('generate-button-text').classList.toggle('hidden', isLoading);
            document.getElementById('generate-button-spinner').classList.toggle('hidden', !isLoading);
        }

        function setupTagInput(inputId, containerId, bgColorClass, autocompleteId, apiEndpoint) {
            const input = document.getElementById(inputId);
            const container = document.getElementById(containerId);
            const autocompleteContainer = document.getElementById(autocompleteId);
            let tags = [];
            let debounceTimer;
            input.addEventListener('input', () => {
                clearTimeout(debounceTimer);
                const query = input.value.trim();
                if (query.length < 2) { autocompleteContainer.classList.add('hidden'); return; }
                debounceTimer = setTimeout(() => fetchAutocomplete(query), 300);
            });
            document.addEventListener('click', (e) => { if (!e.target.closest('.relative')) { autocompleteContainer.classList.add('hidden'); } });
            async function fetchAutocomplete(query) {
                try {
                    const response = await fetch(`${API_BASE_URL}${apiEndpoint}?q=${encodeURIComponent(query)}`);
                    const results = await response.json();
                    renderAutocomplete(results);
                } catch (error) { console.error("Autocomplete fetch failed:", error); }
            }
            function renderAutocomplete(results) {
                autocompleteContainer.innerHTML = '';
                if (results.length > 0) {
                    autocompleteContainer.classList.remove('hidden');
                    results.forEach(result => {
                        const item = document.createElement('div');
                        item.className = 'autocomplete-item';
                        item.textContent = result;
                        item.addEventListener('click', () => { addTag(result); input.value = ''; autocompleteContainer.classList.add('hidden'); });
                        autocompleteContainer.appendChild(item);
                    });
                } else { autocompleteContainer.classList.add('hidden'); }
            }
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim() !== '') {
                    e.preventDefault(); addTag(input.value.trim()); input.value = ''; autocompleteContainer.classList.add('hidden');
                }
            });
            function addTag(label) { if (!tags.includes(label)) { tags.push(label); renderTags(); } }
            function removeTag(label) { tags = tags.filter(tag => tag !== label); renderTags(); }
            function renderTags() {
                container.innerHTML = '';
                tags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = `tag ${bgColorClass}`;
                    tagEl.innerHTML = `<span>${tag}</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tag-remove"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
                    tagEl.querySelector('.tag-remove').addEventListener('click', () => removeTag(tag));
                    container.appendChild(tagEl);
                });
            }
            return { getTags: () => tags };
        }

        function createReelItemHTML(anime) {
            if (!anime || !anime.id) return '';
            animeDetailsCache[anime.id] = anime;
            recommendationScores[anime.id] = anime.initial_score;
            if (!recommendationSignals[anime.id]) recommendationSignals[anime.id] = new Set();
            
            const mainGenresHTML = (anime.genres || '').split(',').slice(0, 3).map(g => `<span class="inline-block bg-indigo-500/20 text-indigo-300 text-xs font-medium mr-2 mb-2 px-2.5 py-1 rounded-full">${g.trim()}</span>`).join('');
            const posKeywordsHTML = (anime.positive_keywords || '').split(', ').filter(Boolean).map(k => `<span class="bg-green-500/20 text-green-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${k}</span>`).join('') || '<span class="text-gray-400 text-xs">None identified.</span>';
            const negKeywordsHTML = (anime.negative_keywords || '').split(', ').filter(Boolean).map(k => `<span class="bg-red-500/20 text-red-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${k}</span>`).join('') || '<span class="text-gray-400 text-xs">None identified.</span>';
            const commentsHTML = (anime.comments || []).map(c => `<div class="border-l-2 ${c.type === 'positive' ? 'border-green-500/50' : 'border-red-500/50'} pl-3 mb-3"><p class="text-sm text-gray-200"><strong>${c.user}:</strong> ${c.text}</p></div>`).join('');
            const synopsisHTML = anime.synopsis ? `<p class="text-sm text-gray-300 mb-3">${anime.synopsis.substring(0, 250)}...</p>` : '';
            const genresHTML = (anime.genres || '').split(',').map(g => `<span class="bg-gray-700 text-gray-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${g.trim()}</span>`).join('') || '<span class="text-gray-400 text-xs">Not available.</span>';

            return `<div class="reel-item relative h-full w-full flex-shrink-0" data-anime-id="${anime.id}" data-anime-title="${anime.title}">
                        <div class="absolute inset-0 bg-black">${anime.trailerId ? `<div id="player-${anime.id}"></div>` : '<div class="w-full h-full flex items-center justify-center text-gray-400">Trailer Not Available</div>'}</div>
                        <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div>
                        <div class="absolute right-4 bottom-24 flex flex-col items-center space-y-4 z-10">
                            <button class="action-btn like-btn bg-black/30 p-3 rounded-full hover:bg-pink-500 transition-all" title="Like"><i data-lucide="heart"></i></button>
                            <button class="action-btn save-btn bg-black/30 p-3 rounded-full hover:bg-indigo-500 transition-all" title="Save to Watchlist"><i data-lucide="bookmark"></i></button>
                            <button class="action-btn not-interested-btn bg-black/30 p-3 rounded-full hover:bg-red-500 transition-all" title="Not Interested"><i data-lucide="thumbs-down"></i></button>
                        </div>
                        <div class="absolute bottom-0 left-0 right-0 p-4 text-white">
                            <h2 class="text-2xl font-bold">${anime.title}</h2>
                            <p class="text-sm text-gray-300 my-2 cursor-pointer show-details-btn">Score: ${anime.score != null ? anime.score.toFixed(1) : 'N/A'} | Rank: #${anime.rank || 'N/A'} (Click for details...)</p>
                            <div class="flex flex-wrap mt-2">${mainGenresHTML}</div>
                            <div class="details-panel hidden bg-black/50 backdrop-blur-sm p-3 rounded-lg mt-2 max-h-48 overflow-y-auto">
                                <h4 class="font-semibold text-sm text-gray-300">Synopsis:</h4>${synopsisHTML}
                                <h4 class="font-semibold text-sm text-gray-300 mt-3">Genres:</h4><div class="flex flex-wrap my-2">${genresHTML}</div>
                                <h4 class="font-semibold text-sm text-green-400">Praised Aspects:</h4><div class="flex flex-wrap my-2">${posKeywordsHTML}</div>
                                <h4 class="font-semibold text-sm text-red-400">Criticized Aspects:</h4><div class="flex flex-wrap my-2">${negKeywordsHTML}</div>
                                <h4 class="font-semibold text-sm text-gray-300 mt-3">Sampled Reviews:</h4><div class="mt-2">${commentsHTML}</div>
                            </div>
                        </div>
                    </div>`;
        }

        function createEndCard() {
            const endCard = document.createElement('div');
            endCard.className = 'reel-item flex flex-col items-center justify-center text-center p-8';
            endCard.id = 'end-card';
            endCard.innerHTML = `<h2 class="text-2xl font-bold mb-2">You've reached the end!</h2><p class="text-gray-400">Like or dislike to refine your queue.</p><button id="refresh-btn" class="mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Get More Recommendations</button>`;
            endCard.querySelector('#refresh-btn').addEventListener('click', refreshRecommendations);
            return endCard;
        }

        function loadReels(animeData) {
            reelContainer.innerHTML = '';
            players = {}; recommendationScores = {}; recommendationSignals = {};
            seenAnimeIds.clear(); animeDetailsCache = {}; sessionScrolledPastIds.clear();
            activeReelId = null; 
            animeData.forEach(anime => { reelContainer.insertAdjacentHTML('beforeend', createReelItemHTML(anime)); });
            reelContainer.appendChild(createEndCard());
            lucide.createIcons();
            setupIntersectionObserver();
            updateRankingPanel();
        }
        
        function appendReels(animeData) {
            const endCard = document.getElementById('end-card');
            if (!endCard) return;
            animeData.forEach(anime => {
                if (!animeDetailsCache[anime.id]) {
                    endCard.insertAdjacentHTML('beforebegin', createReelItemHTML(anime));
                }
            });
            lucide.createIcons();
            setupIntersectionObserver();
            updateRankingPanel();
        }

        async function preloadInitialReels(reels) {
            if (!isApiReady) await apiReadyPromise;
            const reelsToPreload = reels.slice(0, 5).filter(r => r.trailerId);
            const preloadPromises = reelsToPreload.map(anime => {
                return new Promise(resolve => {
                    players[anime.id] = new YT.Player(`player-${anime.id}`, {
                        height: '100%', width: '100%', videoId: anime.trailerId,
                        playerVars: { 'autoplay': 0, 'controls': 0, 'showinfo': 0, 'rel': 0, 'loop': 1, 'playlist': anime.trailerId, 'mute': 1 },
                        events: { 'onReady': () => resolve() }
                    });
                });
            });
            await Promise.all(preloadPromises);
        }

        function createPlayer(animeId, videoId) {
            return new YT.Player(`player-${animeId}`, {
                height: '100%', width: '100%', videoId: videoId,
                playerVars: { 'autoplay': 0, 'controls': 0, 'showinfo': 0, 'rel': 0, 'loop': 1, 'playlist': videoId, 'mute': isMuted ? 1 : 0 }
            });
        }

        function setupIntersectionObserver() {
            if (intersectionObserver) intersectionObserver.disconnect();
            intersectionObserver = new IntersectionObserver((entries) => {
                // This logic is simplified to handle one transition at a time
                const visibleEntry = entries.find(e => e.isIntersecting);

                if (visibleEntry) {
                    const newVisibleId = visibleEntry.target.dataset.animeId;
                    if (newVisibleId === activeReelId) return;

                    // This block runs when we scroll AWAY from the previous reel
                    if (activeReelId) {
                        const oldPlayer = players[activeReelId];
                        if (oldPlayer && typeof oldPlayer.stopVideo === 'function') oldPlayer.stopVideo();
                        stopProgressCheck(activeReelId);
                        
                        const oldSignals = recommendationSignals[activeReelId] || new Set();
                        // If no manual or positive automatic signal was given, it's a "watched" (scrolled-past) event.
                        if (oldSignals.size === 0) {
                            const oldIdInt = parseInt(activeReelId, 10);
                            sessionScrolledPastIds.add(oldIdInt);
                            sendFeedbackSignal(oldIdInt, 'scrolled_past', true).then(() => rescoreRemainingReels());
                        }
                    }
                    
                    // This block runs for the NEW reel that is now visible
                    activeReelId = newVisibleId;
                    currentlyVisibleReel = visibleEntry.target;
                    const animeIdInt = parseInt(activeReelId, 10);
                    seenAnimeIds.add(animeIdInt);
                    
                    const trailerId = animeDetailsCache[activeReelId]?.trailerId;
                    if (trailerId && !players[activeReelId]) {
                        players[activeReelId] = createPlayer(activeReelId, trailerId);
                    }
                    const player = players[activeReelId];
                    if (player && typeof player.playVideo === 'function') {
                        if (!isMuted) player.unMute();
                        setTimeout(() => player.playVideo(), 100);
                    }
                    if (player) startProgressCheck(activeReelId, player);
                }
            }, { root: reelContainer, threshold: 0.7 });

            document.querySelectorAll('.reel-item[data-anime-id]').forEach(item => intersectionObserver.observe(item));
        }

        function startProgressCheck(animeId, player) {
            stopProgressCheck(animeId);
            progressCheckIntervals[animeId] = setInterval(() => {
                if (player && typeof player.getCurrentTime === 'function' && player.getPlayerState() === 1) {
                    const currentTime = player.getCurrentTime();
                    if (currentTime >= 10 && !recommendationSignals[animeId]?.has('watched_10_seconds')) {
                        const animeIdInt = parseInt(animeId, 10);
                        sendFeedbackSignal(animeIdInt, 'watched_10_seconds', true);
                        // --- FIX: Also add to the client-side filter immediately ---
                        sessionScrolledPastIds.add(animeIdInt); 
                    }
                }
            }, 1000);
        }

        function stopProgressCheck(animeId) {
            if (progressCheckIntervals[animeId]) {
                clearInterval(progressCheckIntervals[animeId]);
                delete progressCheckIntervals[animeId];
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            setupScreen = document.getElementById('setup-screen');
            reelsScreen = document.getElementById('reels-screen');
            generateButton = document.getElementById('generate-button');
            reelContainer = document.getElementById('reel-container');
            exitButton = document.getElementById('exit-session-button');
            unmuteButton = document.getElementById('unmute-button');
            unmuteOverlay = document.getElementById('unmute-overlay');
            rankingPanelContainer = document.getElementById('ranking-panel-container');
            initialLoadingOverlay = document.getElementById('initial-loading-overlay');
            
            inputs = {
                username: document.getElementById('username-input'),
                genres: setupTagInput('genres-input', 'genres-tags', 'bg-indigo-500/80', 'genres-autocomplete', '/api/search_genres'),
                liked: setupTagInput('liked-input', 'liked-tags', 'bg-green-500/80', 'liked-autocomplete', '/api/search_anime'),
                disliked: setupTagInput('disliked-input', 'disliked-tags', 'bg-red-500/80', 'disliked-autocomplete', '/api/search_anime')
            };

            generateButton.addEventListener('click', onGenerateReel);
            exitButton.addEventListener('click', onExitSession);
            unmuteButton.addEventListener('click', onToggleMute);
            unmuteOverlay.addEventListener('click', onToggleMute);
            
            async function handleAction(animeId, reason, reelItem, btnElement) {
                const feedbackData = await sendFeedbackSignal(animeId, reason);
                
                if (reason === 'like_button' || reason === 'super_like_button' || reason === 'not_interested_button') {
                    const nextElement = reelItem.nextElementSibling;
                    if (feedbackData && feedbackData.affected_ids) {
                        feedbackData.affected_ids.forEach(id => {
                            const itemToRemove = document.querySelector(`.reel-item[data-anime-id='${id}']`);
                            if (itemToRemove) {
                                intersectionObserver.unobserve(itemToRemove);
                                itemToRemove.remove();
                            }
                            delete players[id];
                            if (reason === 'not_interested_button') {
                                delete recommendationScores[id];
                                delete animeDetailsCache[id];
                                delete recommendationSignals[id];
                            }
                        });
                    }
                    updateRankingPanel();
                    if (nextElement) nextElement.scrollIntoView({ behavior: 'smooth' });
                    refreshRecommendations();
                } else if (reason === 'save_to_watchlist') {
                    btnElement.classList.toggle('active-btn');
                }
                rescoreRemainingReels();
            }

            reelContainer.addEventListener('click', async (e) => {
                const detailsBtn = e.target.closest('.show-details-btn');
                if (detailsBtn) {
                    detailsBtn.closest('.reel-item').querySelector('.details-panel').classList.toggle('hidden');
                    return;
                }
                const btn = e.target.closest('.action-btn');
                if (!btn) return;
                const reelItem = btn.closest('.reel-item');
                if (!reelItem) return;
                
                const animeId = parseInt(reelItem.dataset.animeId, 10);
                
                if (btn.classList.contains('like-btn')) {
                    clearTimeout(likeClickTracker.timer);
                    if (likeClickTracker.animeId === animeId) {
                        likeClickTracker.count++;
                    } else {
                        likeClickTracker.animeId = animeId;
                        likeClickTracker.count = 1;
                    }

                    if (likeClickTracker.count >= 3) { // Changed to 3
                        showSuperLikeToast();
                        await handleAction(animeId, 'super_like_button', reelItem, btn);
                        likeClickTracker = { animeId: null, count: 0, timer: null };
                    } else {
                        likeClickTracker.timer = setTimeout(async () => {
                            if (likeClickTracker.count === 1) {
                                await handleAction(animeId, 'like_button', reelItem, btn);
                            }
                            likeClickTracker = { animeId: null, count: 0, timer: null };
                        }, 400);
                    }
                    return; 
                }
                
                const actionMap = { 'save-btn': 'save_to_watchlist', 'not-interested-btn': 'not_interested_button' };
                for (const cls in actionMap) {
                    if (btn.classList.contains(cls)) {
                        await handleAction(animeId, actionMap[cls], reelItem, btn);
                        break;
                    }
                }
            });
            
            reelContainer.addEventListener('mousedown', (e) => {
                 if (e.target.closest('.action-btn') || e.target.closest('.show-details-btn')) return;
                 if (e.clientX > reelContainer.offsetWidth / 2) {
                     if (currentlyVisibleReel) {
                         const activePlayer = players[currentlyVisibleReel.dataset.animeId];
                         if (activePlayer && typeof activePlayer.setPlaybackRate === 'function') {
                             activePlayer.setPlaybackRate(2);
                         }
                     }
                 }
            });
            document.addEventListener('mouseup', () => {
                if (currentlyVisibleReel) {
                    const activePlayer = players[currentlyVisibleReel.dataset.animeId];
                    if (activePlayer && typeof activePlayer.setPlaybackRate === 'function') {
                        activePlayer.setPlaybackRate(1);
                    }
                }
            });
        });
    </script>
</body>
</html>