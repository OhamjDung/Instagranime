<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Reels - Find Your Next Watch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Inter', sans-serif; -webkit-tap-highlight-color: transparent; }
        .tag { display: inline-flex; align-items: center; padding: 4px 10px; margin: 4px; border-radius: 9999px; font-size: 0.875rem; font-weight: 500; }
        .tag-remove { margin-left: 8px; cursor: pointer; width: 16px; height: 16px; }
        .details-panel::-webkit-scrollbar, .ranking-panel::-webkit-scrollbar { display: none; }
        .details-panel, .ranking-panel { -ms-overflow-style: none; scrollbar-width: none; }
        .reel-container { scroll-snap-type: y mandatory; overflow-y: scroll; -ms-overflow-style: none; scrollbar-width: none; }
        .reel-container::-webkit-scrollbar { display: none; }
        .reel-item { scroll-snap-align: start; flex: 0 0 100%; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; }
        .autocomplete-results { position: absolute; background-color: #1f2937; border: 1px solid #4b5563; border-radius: 0.5rem; max-height: 150px; overflow-y: auto; width: 100%; z-index: 10; margin-top: 4px; }
        .autocomplete-item { padding: 8px 12px; cursor: pointer; }
        .autocomplete-item:hover { background-color: #374151; }
        .spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-left-color: #fff; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-900 text-white h-full antialiased overflow-hidden flex">

    <audio id="audio-unlocker" muted playsinline></audio>

    <div id="initial-loading-overlay" class="hidden absolute inset-0 bg-gray-900/90 backdrop-blur-sm flex flex-col items-center justify-center z-50 transition-opacity duration-300">
        <div class="spinner"></div>
        <p class="mt-4 text-lg font-semibold">Preparing your recommendations...</p>
    </div>

    <div class="flex-grow h-full relative">
        <div id="setup-screen" class="min-h-full flex flex-col items-center justify-center p-4 transition-opacity duration-500">
            <div class="w-full max-w-2xl mx-auto bg-gray-800/50 backdrop-blur-sm rounded-2xl p-6 md:p-8 shadow-2xl border border-gray-700 fade-in">
                <div class="text-center mb-8"><h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500">AnimeReels</h1><p class="text-gray-300 mt-2">Tell us your tastes to create your personalized reel.</p></div>
                <div class="mb-4"><label class="block text-sm font-medium text-gray-200 mb-2">Your Username (for this session)</label><input id="username-input" type="text" placeholder="Enter a temporary username..." class="w-full bg-gray-900 rounded-lg p-3 border border-gray-700 focus:ring-2 focus:ring-indigo-500 outline-none"></div>
                <div class="mb-4 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Must-Have Genres</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-indigo-500"><div id="genres-tags" class="flex flex-wrap"></div><input id="genres-input" type="text" placeholder="Type genre and press Enter..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="genres-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="mb-4 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Animes You Like</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-green-500"><div id="liked-tags" class="flex flex-wrap"></div><input id="liked-input" type="text" placeholder="e.g., Attack on Titan..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="liked-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="mb-6 relative"><label class="block text-sm font-medium text-gray-200 mb-2">Animes You Dislike</label><div class="bg-gray-900 rounded-lg p-2 flex flex-wrap items-center border border-gray-700 focus-within:ring-2 focus-within:ring-red-500"><div id="disliked-tags" class="flex flex-wrap"></div><input id="disliked-input" type="text" placeholder="e.g., Sword Art Online..." class="bg-transparent text-white outline-none flex-grow p-2 min-w-[150px]"></div><div id="disliked-autocomplete" class="autocomplete-results hidden"></div></div>
                <div class="flex items-center justify-center my-4"><label for="explicit-toggle" class="flex items-center cursor-pointer text-sm text-gray-400"><input type="checkbox" id="explicit-toggle" class="form-checkbox h-4 w-4 text-indigo-600 bg-gray-800 border-gray-600 rounded focus:ring-indigo-500"><span class="ml-2">Show Explicit Genres</span></label></div>
                <button id="generate-button" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-500/50 disabled:bg-gray-500 disabled:hover:bg-gray-500 disabled:scale-100 flex items-center justify-center"><span id="generate-button-text">Generate My Reel</span><span id="generate-button-spinner" class="hidden"><svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></span></button>
            </div>
        </div>

        <div id="reels-screen" class="h-full w-full max-w-md mx-auto relative hidden flex-col">
            <div id="reel-container" class="reel-container h-full w-full"></div>
            <button id="exit-session-button" title="Exit and Delete Session Data" class="absolute top-4 left-4 bg-black/30 p-2.5 rounded-full hover:bg-black/50 transition-all z-20"><svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
            <button id="unmute-button" title="Unmute Video" class="absolute top-4 right-4 bg-black/30 p-2.5 rounded-full hover:bg-black/50 transition-all z-20"><i data-lucide="volume-x" class="w-5 h-5"></i></button>
            <div id="unmute-overlay" class="absolute inset-0 bg-black/50 flex items-center justify-center z-30 cursor-pointer"><div class="text-center"><i data-lucide="volume-x" class="w-16 h-16 mx-auto"></i><p class="mt-4 font-semibold">Tap to Unmute</p></div></div>
        </div>
    </div>
    
    <div id="ranking-panel-container" class="w-64 bg-gray-800/50 border-l border-gray-700 h-full flex-shrink-0 p-4 hidden ranking-panel overflow-y-auto">
        <h3 class="text-lg font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500 mb-4">Your Bashboard</h3>
        <div id="ranking-list"></div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // --- CONFIG & STATE ---
        const API_BASE_URL = 'https://instagranime-1.onrender.com';
        // const API_BASE_URL = 'http://127.0.0.1:5000'
        let currentUserId = null, players = {}, isMuted = true, recommendationScores = {}, recommendationSignals = {}, seenAnimeIds = new Set(), isRefreshing = false, currentlyVisibleReel = null, progressCheckIntervals = {}, animeDetailsCache = {}, userTasteProfile = {}, isApiReady = false, hasUnlockedAudio = false, isFeedbackLocked = false;
        let apiReadyPromise = new Promise(resolve => { window.onYouTubeIframeAPIReady = () => { isApiReady = true; resolve(); }; });
        
        // --- DOM ELEMENT & LOGIC VARIABLES ---
        let setupScreen, reelsScreen, generateButton, reelContainer, exitButton, unmuteButton, unmuteOverlay, rankingPanelContainer, initialLoadingOverlay;
        let inputs = {};
        let intersectionObserver;

        // --- CORE FUNCTIONS ---
        function reorderUpcomingReel() { if (!currentlyVisibleReel) return; const sortedAnime = Object.entries(recommendationScores).sort((a, b) => b[1] - a[1]); for (const [animeId] of sortedAnime) { const targetReel = reelContainer.querySelector(`[data-anime-id='${animeId}']`); if (targetReel && targetReel !== currentlyVisibleReel) { currentlyVisibleReel.after(targetReel); setupIntersectionObserver(); break; } } }
        function rescoreAllVisibleReels() { console.log("Re-scoring all recommendations based on new taste profile..."); for (const animeId in animeDetailsCache) { if (Object.hasOwnProperty.call(animeDetailsCache, animeId)) { const details = animeDetailsCache[animeId]; let newScore = 0; if (details.positive_keywords) { for (const keyword of details.positive_keywords.split(', ')) { if (keyword) newScore += userTasteProfile[keyword] || 0; } } if (details.negative_keywords) { for (const keyword of details.negative_keywords.split(', ')) { if (keyword) newScore -= userTasteProfile[keyword] || 0; } } recommendationScores[animeId] = newScore; } } updateRankingPanel(); reorderUpcomingReel(); }
        
        // --- MODIFIED: A single, unified feedback function that now handles score modifiers correctly ---
        async function sendFeedbackSignal(animeId, animeTitle, signalType, reason, scoreModifier = 0) {
            const isAutomaticSignal = (reason === 'watched_10_seconds' || reason === 'low_watch_time');
            if (isAutomaticSignal && isFeedbackLocked) {
                return;
            }
            if (!isAutomaticSignal && isFeedbackLocked) {
                return;
            }
            isFeedbackLocked = true;

            try {
                console.log(`[FEEDBACK]`, { type: isAutomaticSignal ? 'Light' : 'Heavy', reason, scoreModifier });

                if (recommendationScores[animeId] !== undefined) {
                    // --- FIX: Apply score modifier for ALL signals for instant feedback ---
                    recommendationScores[animeId] += scoreModifier;
                    if (!recommendationSignals[animeId]) recommendationSignals[animeId] = new Set();
                    
                    if (isAutomaticSignal) {
                        recommendationSignals[animeId].add(reason);
                    } else {
                        if (recommendationSignals[animeId].has(reason)) {
                            recommendationSignals[animeId].delete(reason);
                        } else {
                            recommendationSignals[animeId].add(reason);
                        }
                    }
                    updateRankingPanel();
                }
                const response = await fetch(`${API_BASE_URL}/api/feedback`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user_id: currentUserId, animeId, animeTitle, signalType, reason }) });
                const data = await response.json();
                
                if (data.taste_profile && !isAutomaticSignal) {
                    userTasteProfile = data.taste_profile;
                    rescoreAllVisibleReels();
                }
            } catch (error) { 
                console.error("Failed to send feedback:", error); 
            } finally {
                isFeedbackLocked = false;
            }

            if (['like_button', 'not_interested_button', 'save_to_watchlist'].includes(reason)) {
                refreshRecommendations();
            }
        }
        
        async function refreshRecommendations() { if (isRefreshing) return; isRefreshing = true; const allowExplicit = document.getElementById('explicit-toggle').checked; const payload = { user_id: currentUserId, seen_anime_ids: Array.from(seenAnimeIds), genres: inputs.genres.getTags(), liked_anime: inputs.liked.getTags(), disliked_anime: inputs.disliked.getTags(), allow_explicit: allowExplicit }; try { const response = await fetch(`${API_BASE_URL}/api/generate_reel`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); const data = await response.json(); if (data.recommendations && data.recommendations.length > 0) { appendReels(data.recommendations); } } catch (error) { console.error("Failed to refresh recommendations:", error); } finally { isRefreshing = false; } }
        async function onGenerateReel() { const username = inputs.username.value.trim(); if (!username) { alert("Please enter a username."); return; } const allowExplicit = document.getElementById('explicit-toggle').checked; const payload = { username, genres: inputs.genres.getTags(), liked_anime: inputs.liked.getTags(), disliked_anime: inputs.disliked.getTags(), allow_explicit: allowExplicit }; toggleLoading(true); try { const response = await fetch(`${API_BASE_URL}/api/generate_reel`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `HTTP error! status: ${response.status}`); } const data = await response.json(); currentUserId = data.user_id; userTasteProfile = data.taste_profile; initialLoadingOverlay.classList.remove('hidden'); initialLoadingOverlay.style.opacity = '1'; setupScreen.style.opacity = '0'; loadReels(data.recommendations, data.recommendation_type); await preloadInitialReels(data.recommendations); if (data.recommendations.length > 0 && data.recommendations[0].trailerId) { const firstAnimeId = data.recommendations[0].id; const firstPlayer = players[firstAnimeId]; if (firstPlayer && typeof firstPlayer.playVideo === 'function') { firstPlayer.unMute(); firstPlayer.playVideo(); await new Promise(resolve => setTimeout(resolve, 150)); firstPlayer.pauseVideo(); firstPlayer.seekTo(0, true); if (isMuted) { firstPlayer.mute(); } } } initialLoadingOverlay.style.opacity = '0'; setTimeout(() => { initialLoadingOverlay.classList.add('hidden'); setupScreen.classList.add('hidden'); reelsScreen.classList.remove('hidden'); reelsScreen.classList.add('flex'); rankingPanelContainer.classList.remove('hidden'); reelsScreen.style.opacity = '1'; }, 300); } catch (error) { console.error('Failed to fetch recommendations:', error); alert(`Error: ${error.message}`); initialLoadingOverlay.classList.add('hidden'); } finally { toggleLoading(false); } }
        async function onExitSession() { if (currentUserId) { try { await fetch(`${API_BASE_URL}/api/user/${currentUserId}`, { method: 'DELETE' }); } catch (error) { console.error("Error deleting user:", error); } } reelsScreen.style.opacity = '0'; rankingPanelContainer.classList.add('hidden'); setTimeout(() => { reelsScreen.classList.add('hidden'); reelsScreen.classList.remove('flex'); setupScreen.classList.remove('hidden'); setupScreen.style.opacity = '1'; Object.values(players).forEach(p => { if (p && typeof p.destroy === 'function') p.destroy(); }); reelContainer.innerHTML = ''; players = {}; currentUserId = null; recommendationScores = {}; recommendationSignals = {}; seenAnimeIds.clear(); currentlyVisibleReel = null; animeDetailsCache = {}; userTasteProfile = {}; inputs.username.value = ''; inputs.genres.resetTags(); inputs.liked.resetTags(); inputs.disliked.resetTags(); }, 500); }
        function onToggleMute() { if (!hasUnlockedAudio) { document.getElementById('audio-unlocker').play().catch(e => {}); document.getElementById('audio-unlocker').pause(); hasUnlockedAudio = true; console.log('Browser audio context unlocked.'); } isMuted = !isMuted; unmuteOverlay.classList.add('hidden'); const icon = unmuteButton.querySelector('i'); icon.setAttribute('data-lucide', isMuted ? 'volume-x' : 'volume-2'); lucide.createIcons({nodes: [icon]}); Object.values(players).forEach(p => { if(p && typeof p.mute === 'function') { if(isMuted) p.mute(); else p.unMute(); } }); }
        function toggleLoading(isLoading) { const btn = generateButton; const txt = document.getElementById('generate-button-text'); const spin = document.getElementById('generate-button-spinner'); btn.disabled = isLoading; txt.classList.toggle('hidden', isLoading); spin.classList.toggle('hidden', !isLoading); }
        function setupTagInput(inputId, containerId, bgColorClass, autocompleteId = null, apiEndpoint = null) { const input = document.getElementById(inputId); const container = document.getElementById(containerId); const autocompleteContainer = autocompleteId ? document.getElementById(autocompleteId) : null; let tags = []; let debounceTimer; if (autocompleteContainer && apiEndpoint) { input.addEventListener('input', () => { clearTimeout(debounceTimer); const query = input.value.trim(); if (query.length < 1) { autocompleteContainer.innerHTML = ''; autocompleteContainer.classList.add('hidden'); return; } debounceTimer = setTimeout(() => fetchAutocomplete(query), 300); }); document.addEventListener('click', (e) => { if (!e.target.closest('.relative')) { autocompleteContainer.classList.add('hidden'); } }); } async function fetchAutocomplete(query) { try { const response = await fetch(`${API_BASE_URL}${apiEndpoint}?q=${encodeURIComponent(query)}`); const results = await response.json(); renderAutocomplete(results); } catch (error) { console.error("Autocomplete fetch failed:", error); } } function renderAutocomplete(results) { autocompleteContainer.innerHTML = ''; if(results.length > 0) { autocompleteContainer.classList.remove('hidden'); results.forEach(result => { const item = document.createElement('div'); item.className = 'autocomplete-item'; item.textContent = result; item.addEventListener('click', () => { addTag(result); input.value = ''; autocompleteContainer.innerHTML = ''; autocompleteContainer.classList.add('hidden'); }); autocompleteContainer.appendChild(item); }); } else { autocompleteContainer.classList.add('hidden'); } } input.addEventListener('keydown', (e) => { if (e.key === 'Enter' && input.value.trim() !== '') { e.preventDefault(); addTag(input.value.trim()); input.value = ''; if (autocompleteContainer) { autocompleteContainer.innerHTML = ''; autocompleteContainer.classList.add('hidden'); } } }); function addTag(label) { if (!tags.includes(label)) { tags.push(label); renderTags(); } } function removeTag(label) { tags = tags.filter(tag => tag !== label); renderTags(); } function renderTags() { container.innerHTML = ''; tags.forEach(tag => { const tagEl = document.createElement('div'); tagEl.className = `tag ${bgColorClass}`; tagEl.innerHTML = `<span>${tag}</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="tag-remove"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`; tagEl.querySelector('.tag-remove').addEventListener('click', () => removeTag(tag)); container.appendChild(tagEl); }); } function resetTags() { tags = []; renderTags(); } return { getTags: () => tags, resetTags: resetTags }; }
        function createReelItemHTML(anime) { recommendationScores[anime.id] = anime.initial_score; seenAnimeIds.add(anime.id); animeDetailsCache[anime.id] = { title: anime.title, positive_keywords: anime.positive_keywords, negative_keywords: anime.negative_keywords, genres: anime.genres }; const mainGenresHTML = (anime.genres || '').split(',').slice(0, 3).map(g => `<span class="inline-block bg-indigo-500/20 text-indigo-300 text-xs font-medium mr-2 mb-2 px-2.5 py-1 rounded-full">${g.trim()}</span>`).join(''); const posKeywordsHTML = (anime.positive_keywords || '').split(', ').filter(Boolean).map(k => `<span class="bg-green-500/20 text-green-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${k}</span>`).join('') || '<span class="text-gray-400 text-xs">None identified.</span>'; const negKeywordsHTML = (anime.negative_keywords || '').split(', ').filter(Boolean).map(k => `<span class="bg-red-500/20 text-red-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${k}</span>`).join('') || '<span class="text-gray-400 text-xs">None identified.</span>'; const commentsHTML = anime.comments.map(c => `<div class="border-l-2 ${c.type === 'positive' ? 'border-green-500/50' : 'border-red-500/50'} pl-3 mb-3"><p class="text-sm text-gray-200">${c.text}</p></div>`).join(''); const genresHTML = (anime.genres || '').split(',').map(g => `<span class="bg-gray-700 text-gray-300 text-xs font-medium mr-2 mb-2 px-2.5 py-0.5 rounded-full">${g.trim()}</span>`).join('') || '<span class="text-gray-400 text-xs">Not available.</span>'; return `<div class="reel-item relative h-full w-full flex-shrink-0" data-anime-id="${anime.id}" data-anime-title="${anime.title}" data-trailer-id="${anime.trailerId || ''}"><div class="absolute inset-0 bg-black">${anime.trailerId ? `<div id="player-${anime.id}"></div>` : '<div class="w-full h-full flex items-center justify-center text-gray-400">Trailer Not Available</div>'}</div><div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent"></div><div class="absolute right-4 bottom-24 flex flex-col items-center space-y-4 z-10"><button class="action-btn like-btn bg-black/30 p-3 rounded-full hover:bg-pink-500 transition-all"><i data-lucide="heart"></i></button><button class="action-btn save-btn bg-black/30 p-3 rounded-full hover:bg-indigo-500 transition-all"><i data-lucide="bookmark"></i></button><button class="action-btn not-interested-btn bg-black/30 p-3 rounded-full hover:bg-red-500 transition-all"><i data-lucide="thumbs-down"></i></button></div><div class="absolute bottom-0 left-0 right-0 p-4 text-white"><h2 class="text-2xl font-bold">${anime.title}</h2><p class="text-sm text-gray-300 my-2 cursor-pointer show-details-btn">Score: ${anime.score || 'N/A'} | Rank: #${anime.rank || 'N/A'} (Click to see why...)</p><div class="flex flex-wrap mt-2">${mainGenresHTML}</div><div class="details-panel hidden bg-black/50 backdrop-blur-sm p-3 rounded-lg mt-2 max-h-48 overflow-y-auto"><h4 class="font-semibold text-sm text-gray-300">Genres (Full List):</h4><div class="flex flex-wrap my-2">${genresHTML}</div><h4 class="font-semibold text-sm text-green-400">Praised Aspects:</h4><div class="flex flex-wrap my-2">${posKeywordsHTML}</div><h4 class="font-semibold text-sm text-red-400">Criticized Aspects:</h4><div class="flex flex-wrap my-2">${negKeywordsHTML}</div><h4 class="font-semibold text-sm text-gray-300 mt-3">Sampled Reviews:</h4><div class="mt-2">${commentsHTML}</div></div></div></div>`;};
        loadReels = function(animeData, recommendationType = 'personalized') { reelContainer.innerHTML = ''; players = {}; recommendationScores = {}; recommendationSignals = {}; seenAnimeIds.clear(); animeDetailsCache = {}; animeData.forEach(anime => { const itemHTML = createReelItemHTML(anime); reelContainer.insertAdjacentHTML('beforeend', itemHTML); }); const endCard = document.createElement('div'); endCard.className = 'reel-item flex flex-col items-center justify-center text-center p-8'; endCard.id = 'end-card'; if (animeData.length === 0) { endCard.innerHTML = `<h2 class="text-2xl font-bold mb-2">No Matches Found</h2><p class="text-gray-400">We couldn't find any recommendations based on your preferences. Try adjusting your inputs!</p>`; } else { let endCardHTML = (recommendationType === 'fallback') ? `<h2 class="text-2xl font-bold mb-2">That's all for now!</h2><p class="text-gray-400">We showed you popular anime as we couldn't find a perfect match. <br><br>Refine your tastes for better recommendations.</p>` : `<h2 class="text-2xl font-bold mb-2">You've reached the end!</h2><p class="text-gray-400">Keep interacting to get new recommendations, or exit and refine your tastes.</p>`; endCard.innerHTML = endCardHTML; } reelContainer.appendChild(endCard); lucide.createIcons(); setupIntersectionObserver(); updateRankingPanel(); };
        appendReels = function(animeData) { const endCard = document.getElementById('end-card'); if (!endCard) return; animeData.forEach(anime => { const itemHTML = createReelItemHTML(anime); endCard.insertAdjacentHTML('beforebegin', itemHTML); }); lucide.createIcons(); setupIntersectionObserver(); updateRankingPanel(); };
        updateRankingPanel = function() { const rankingList = document.getElementById('ranking-list'); const sortedAnime = Object.entries(recommendationScores).sort((a, b) => b[1] - a[1]); const signalToIcon = { 'like_button': '<i data-lucide="heart" class="w-3 h-3 text-pink-400"></i>', 'save_to_watchlist': '<i data-lucide="bookmark" class="w-3 h-3 text-indigo-400"></i>', 'not_interested_button': '<i data-lucide="thumbs-down" class="w-3 h-3 text-red-400"></i>', 'watched_10_seconds': '<i data-lucide="play-circle" class="w-3 h-3 text-green-400"></i>','low_watch_time': '<i data-lucide="skip-forward" class="w-3 h-3 text-red-400"></i>' }; rankingList.innerHTML = sortedAnime.map(([id, score], index) => { const title = animeDetailsCache[id] ? animeDetailsCache[id].title : 'Unknown'; const signals = Array.from(recommendationSignals[id] || []); const signalIconsHTML = signals.map(sig => signalToIcon[sig] || '').join(''); return `<div class="flex items-center justify-between mb-3 text-sm"><span class="font-bold text-indigo-400 mr-2">${index + 1}.</span><span class="flex-grow truncate text-gray-300">${title}</span><span class="flex items-center space-x-1 ml-2">${signalIconsHTML}</span><span class="font-medium text-gray-400 ml-2">${score.toFixed(2)}</span></div>`; }).join(''); lucide.createIcons(); };
        preloadInitialReels = async function(reels) { if (!isApiReady) { await apiReadyPromise; } const reelsToPreload = reels.slice(0, 10).filter(r => r.trailerId); const preloadPromises = reelsToPreload.map(anime => { return new Promise(resolve => { players[anime.id] = new YT.Player(`player-${anime.id}`, { height: '100%', width: '100%', videoId: anime.trailerId, playerVars: { 'autoplay': 0, 'controls': 0, 'showinfo': 0, 'rel': 0, 'loop': 1, 'playlist': anime.trailerId, 'mute': 1 }, events: { 'onReady': () => resolve() } }); }); }); await Promise.all(preloadPromises); console.log("Initial players are preloaded and ready."); };
        createPlayer = function(animeId, videoId) { return new YT.Player(`player-${animeId}`, { height: '100%', width: '100%', videoId: videoId, playerVars: { 'autoplay': 0, 'controls': 0, 'showinfo': 0, 'rel': 0, 'loop': 1, 'playlist': videoId, 'mute': isMuted ? 1 : 0 }, events: { 'onReady': (event) => event.target.setPlaybackQuality('hd720') } }); };
        setupIntersectionObserver = function() { if (intersectionObserver) intersectionObserver.disconnect(); intersectionObserver = new IntersectionObserver((entries) => { entries.forEach(entry => { const animeId = entry.target.dataset.animeId; if (!animeId) return; if (entry.isIntersecting) { currentlyVisibleReel = entry.target; if (!players[animeId]) { const trailerId = entry.target.dataset.trailerId; if (trailerId) { players[animeId] = createPlayer(animeId, trailerId); } } const player = players[animeId]; if (player && typeof player.playVideo === 'function') { if (!isMuted) player.unMute(); setTimeout(() => player.playVideo(), 50); } entry.target.dataset.viewStartTime = Date.now(); if (player) startProgressCheck(animeId, entry.target.dataset.animeTitle, player); const safeZoneIds = new Set(); if(currentlyVisibleReel) safeZoneIds.add(currentlyVisibleReel.dataset.animeId); if (currentlyVisibleReel.previousElementSibling) safeZoneIds.add(currentlyVisibleReel.previousElementSibling.dataset.animeId); const nextReel = currentlyVisibleReel.nextElementSibling; if (nextReel) { safeZoneIds.add(nextReel.dataset.animeId); if (nextReel.nextElementSibling) safeZoneIds.add(nextReel.nextElementSibling.dataset.animeId); } for (const pId in players) { if (!safeZoneIds.has(pId)) { if (players[pId] && typeof players[pId].destroy === 'function') { players[pId].destroy(); delete players[pId]; } } } const reelsToPreload = [nextReel, nextReel?.nextElementSibling]; reelsToPreload.forEach(reelToPreload => { if (reelToPreload && reelToPreload.dataset.animeId) { const preloadId = reelToPreload.dataset.animeId; const preloadTrailerId = reelToPreload.dataset.trailerId; if (preloadId && preloadTrailerId && !players[preloadId]) { players[preloadId] = createPlayer(preloadId, preloadTrailerId); } } }); } else { const player = players[animeId]; if (player && typeof player.stopVideo === 'function') { player.stopVideo(); } const startTime = entry.target.dataset.viewStartTime; if (startTime) { const watchTime = (Date.now() - startTime) / 1000; const maxWatchTime = parseFloat(entry.target.dataset.maxWatchTime || 0); if (watchTime > 0 && maxWatchTime > 0 && maxWatchTime < 5) { sendFeedbackSignal(animeId, entry.target.dataset.animeTitle, 'negative', 'low_watch_time', -2); } entry.target.dataset.viewStartTime = null; } if (player) stopProgressCheck(animeId); } }); }, { root: reelContainer, threshold: 0.7 }); document.querySelectorAll('.reel-item').forEach(item => intersectionObserver.observe(item)); };
        startProgressCheck = function(animeId, animeTitle, player) { const reelItem = document.querySelector(`[data-anime-id='${animeId}']`); if (!reelItem) return; reelItem.dataset.highWatchTimeSignalSent = 'false'; progressCheckIntervals[animeId] = setInterval(() => { if (player && typeof player.getCurrentTime === 'function') { const currentTime = player.getCurrentTime(); reelItem.dataset.maxWatchTime = currentTime.toFixed(2); if (currentTime >= 10 && reelItem.dataset.highWatchTimeSignalSent === 'false') { sendFeedbackSignal(animeId, animeTitle, 'positive', 'watched_10_seconds', 3); reelItem.dataset.highWatchTimeSignalSent = 'true'; } } }, 1000); };
        stopProgressCheck = function(animeId) { if (progressCheckIntervals[animeId]) { clearInterval(progressCheckIntervals[animeId]); delete progressCheckIntervals[animeId]; } };
        
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            setupScreen = document.getElementById('setup-screen');
            reelsScreen = document.getElementById('reels-screen');
            generateButton = document.getElementById('generate-button');
            reelContainer = document.getElementById('reel-container');
            exitButton = document.getElementById('exit-session-button');
            unmuteButton = document.getElementById('unmute-button');
            unmuteOverlay = document.getElementById('unmute-overlay');
            rankingPanelContainer = document.getElementById('ranking-panel-container');
            initialLoadingOverlay = document.getElementById('initial-loading-overlay');
            inputs = { genres: setupTagInput('genres-input', 'genres-tags', 'bg-indigo-500/80 text-white', 'genres-autocomplete', '/api/search_genres'), liked: setupTagInput('liked-input', 'liked-tags', 'bg-green-500/80 text-white', 'liked-autocomplete', '/api/search_anime'), disliked: setupTagInput('disliked-input', 'disliked-tags', 'bg-red-500/80 text-white', 'disliked-autocomplete', '/api/search_anime'), username: document.getElementById('username-input') };
            generateButton.addEventListener('click', onGenerateReel);
            exitButton.addEventListener('click', onExitSession);
            unmuteButton.addEventListener('click', onToggleMute);
            unmuteOverlay.addEventListener('click', onToggleMute);
            reelContainer.addEventListener('click', (e) => { const detailsBtn = e.target.closest('.show-details-btn'); if (detailsBtn) { const detailsPanel = detailsBtn.parentElement.querySelector('.details-panel'); detailsPanel.classList.toggle('hidden'); return; } const btn = e.target.closest('.action-btn'); if (!btn) return; const reelItem = btn.closest('.reel-item'); if (!reelItem) return; const animeId = reelItem.dataset.animeId; const animeTitle = reelItem.dataset.animeTitle; const isActive = btn.classList.contains('active-btn'); const actionMap = { 'like-btn': { reason: 'like_button', score: 5 }, 'save-btn': { reason: 'save_to_watchlist', score: 2 }, 'not-interested-btn': { reason: 'not_interested_button', score: -5 } }; for (const cls in actionMap) { if (btn.classList.contains(cls)) { const { reason, score } = actionMap[cls]; const signalType = (cls === 'not-interested-btn') ? 'negative' : 'positive'; sendFeedbackSignal(animeId, animeTitle, signalType, reason, isActive ? -score : score); btn.classList.toggle('active-btn'); if (cls === 'like-btn' || cls === 'not-interested-btn') { reelItem.remove(); delete players[animeId]; setupIntersectionObserver(); } if (cls === 'not-interested-btn') { reelItem.nextElementSibling?.scrollIntoView({ behavior: 'smooth' }); } } } });
            reelContainer.addEventListener('mousedown', (e) => { if (e.target.closest('.action-btn') || e.target.closest('.show-details-btn')) return; if (e.clientX > reelContainer.offsetWidth / 2) { if (currentlyVisibleReel) { const activePlayer = players[currentlyVisibleReel.dataset.animeId]; if (activePlayer && typeof activePlayer.setPlaybackRate === 'function') { activePlayer.setPlaybackRate(2); } } } });
            document.addEventListener('mouseup', () => { if (currentlyVisibleReel) { const activePlayer = players[currentlyVisibleReel.dataset.animeId]; if (activePlayer && typeof activePlayer.setPlaybackRate === 'function') { activePlayer.setPlaybackRate(1); } } });
        });
    </script>
</body>
</html>